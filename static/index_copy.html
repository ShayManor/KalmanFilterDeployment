<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
	<title>Kalman Filter Step-Through</title>
	<!-- Include Handsontable CSS -->
	<link
	rel="stylesheet"
	href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css"
	/>
	<style>
		body {
			font-family: Arial, sans-serif;
			background: #f7f7f7;
			margin: 20px;
		}
		/* Card-like container for panels */
		.matrix-container {
			background: #fff;
			margin-bottom: 20px;
			padding: 20px;
			border: 1px solid #ddd;
			border-radius: 8px;
			box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
		}
		/* Dimension Form Styles */
		#dimensionForm {
			margin-bottom: 20px;
		}
		/* Flex container to align the inputs in one row */
		#dimensionInputsRow {
			display: flex;
			align-items: center;
			gap: 20px;
		}
		/* Override label to be inline within the flex container */
		#dimensionInputsRow > div label {
			display: inline-block;
			margin-right: 5px;
			font-weight: bold;
		}
		#dimensionForm input[type="number"] {
			width: 80px;
			padding: 8px;
			border: 1px solid #ccc;
			border-radius: 4px;
			transition: border-color 0.3s;
		}
		#dimensionForm input[type="number"]:focus {
			border-color: #007bff;
		}
		/* Dropdown styling */
		#matrixSelect {
			width: 300px;
			padding: 8px;
			font-size: 16px;
			margin-bottom: 15px;
			border: 1px solid #ccc;
			border-radius: 4px;
			transition: border-color 0.3s;
		}
		#matrixSelect:focus {
			border-color: #007bff;
		}
		/* Handsontable container styling */
		.hot-container {
			margin-bottom: 15px;
			/* Set a minimum height so small matrices still look nice */
			min-height: 100px;
		}
		.hidden {
			display: none;
		}
		/* Button styling */
		button {
			background-color: #007bff;
			color: #fff;
			padding: 10px 20px;
			margin: 5px;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 16px;
			transition: background-color 0.3s, transform 0.2s;
		}
		button:hover {
			background-color: #0056b3;
			transform: scale(1.05);
		}
		/* Influence Diagram Styles */
		#graph {
			border: 1px solid #ccc;
			margin-top: 20px;
		}
		.link {
			stroke: #999;
			stroke-width: 2px;
			marker-end: url(#arrow);
		}
		.node circle {
			stroke: black;
			stroke-width: 1px;
			cursor: pointer;
		}
		.nodetext {
			text-anchor: middle;
			dominant-baseline: central;
			font-size: 12px;
		}
		#controls {
			margin: 10px 0;
		}
		/* Modal styling */
		#modalOverlay {
			position: fixed;
			display: none;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: rgba(0, 0, 0, 0.3);
			z-index: 999;
		}
		#modal {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: #fff;
			border: 1px solid #666;
			border-radius: 6px;
			padding: 20px;
			min-width: 300px;
		}
		#closeBtn {
			margin-top: 10px;
		}
		/* Legend styling */
		#legend {
			margin-top: 15px;
			font-size: 14px;
		}
		#legend .legend-item {
			display: flex;
			align-items: center;
			margin-bottom: 5px;
		}
		#legend .legend-color-box {
			width: 20px;
			height: 20px;
			margin-right: 8px;
			border: 1px solid #444;
		}
	</style>
</head>
<body>
	<h1>Kalman Filter Step‚ÄêThrough</h1>
	<!-- Step 1: Matrix Input Section -->
	<div id="matrixInputPanel" class="matrix-container">
		<h2>Step 1: Input Matrices</h2>
		<div id="dimensionForm">
			<div id="dimensionInputsRow">
				<div>
					<label for="nInput">n (State Size):</label>
					<input type="number" id="nInput" value="6" min="1" />
				</div>
				<div>
					<label for="pInput">p (Measurement Size):</label>
					<input type="number" id="pInput" value="2" min="1" />
				</div>
				<div>
					<label for="rInput">r (Noise Size):</label>
					<input type="number" id="rInput" value="6" min="1" />
				</div>
			</div>
			<br /><br />
			<button id="generateMatricesBtn">Generate Matrix Inputs</button>
		</div>
		<div id="matrixInputs" class="hidden">
			<h3>Select Matrix to Edit</h3>
			<!-- Dropdown to select the matrix -->
			<select id="matrixSelect"></select>
			<!-- Container for all Handsontable grids -->
			<div id="matrixGridsContainer"></div>
		</div>
		<button id="resetMatricesBtn" class="hidden">Reset Matrices</button>
		<div id="runPanel" class="hidden">
			<button id="runKalmanBtn">Run Kalman Filter</button>
		</div>
	</div>

	<!-- Step 2: Influence Diagram Panel (hidden until after Run) -->
	<div id="diagramPanel" class="matrix-container hidden">
		<h2>Step 2: Influence Diagram</h2>
		<div id="controls">
			<button id="backToInputBtn">Back to Input</button>
			<button id="prevStepBtn">Previous Step</button>
			<button id="nextStepBtn">Next Step</button>
		</div>
		<svg id="graph" width="1000" height="600"></svg>
		<div id="legend">
			<div class="legend-item">
				<div class="legend-color-box" style="background-color:#f4c2c2;"></div>
				<span>Vector Chance Node</span>
			</div>
			<div class="legend-item">
				<div class="legend-color-box" style="background-color:#00afee;"></div>
				<span>Vector Deterministic Node</span>
			</div>
			<div class="legend-item">
				<div class="legend-color-box" style="background-color:#7f7f7f;"></div>
				<span>Future Node</span>
			</div>
		</div>
	</div>

	<!-- Modal for Node Details -->
	<div id="modalOverlay">
		<div id="modal">
			<div id="modalContent"></div>
			<button id="closeBtn">Close</button>
		</div>
	</div>

	<!-- Include Handsontable and D3 JS -->
	<script src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"></script>
	<script src="https://d3js.org/d3.v7.min.js"></script>
	<script>
		/***** MATRIX INPUT CODE USING HANDSONTABLE WITH MATRIX SELECTION *****/
		const matricesInfo = [
		{ name: "Z", label: "Z (Measurement Values)", rows: (n, p, r) => p, cols: (n, p, r) => 1 },
		{ name: "u", label: "u (State Mean Vector)", rows: (n, p, r) => n, cols: (n, p, r) => 1 },
		{ name: "X", label: "X (Covariance Matrix)", rows: (n, p, r) => n, cols: (n, p, r) => n },
		{ name: "V", label: "V (Measurement Noise)", rows: (n, p, r) => n, cols: (n, p, r) => 1 },
		{ name: "R", label: "R (Measurement Noise Covariance)", rows: (n, p, r) => p, cols: (n, p, r) => p },
		{ name: "H", label: "H (Measurement Matrix)", rows: (n, p, r) => p, cols: (n, p, r) => n },
		{ name: "Phi", label: "Phi (State Transition Matrix)", rows: (n, p, r) => n, cols: (n, p, r) => n },
		{ name: "gamma", label: "gamma (Process Noise Matrix)", rows: (n, p, r) => n, cols: (n, p, r) => r },
		{ name: "Qk", label: "Qk (Process Noise Covariance)", rows: (n, p, r) => r, cols: (n, p, r) => r },
		{ name: "h", label: "h (Expected Measurement Values)", rows: (n, p, r) => p, cols: (n, p, r) => 1 }
		];
		
		// Global object to store Handsontable instances
		const matrixGrids = {};
		
		document.getElementById("generateMatricesBtn").addEventListener("click", function () {
			let n = parseInt(document.getElementById("nInput").value);
			let p = parseInt(document.getElementById("pInput").value);
			let r = parseInt(document.getElementById("rInput").value);
			
			// Ensure n, p, r are not negative.
			if (n < 0) { n = 0; document.getElementById("nInput").value = 0; }
			if (p < 0) { p = 0; document.getElementById("pInput").value = 0; }
			if (r < 0) { r = 0; document.getElementById("rInput").value = 0; }
			
			// Build the matrix selector and container
			const container = document.getElementById("matrixInputs");
			container.innerHTML =
			"<h3>Select Matrix to Edit</h3><select id='matrixSelect'></select><div id='matrixGridsContainer'></div>";
			const selectEl = document.getElementById("matrixSelect");
			const gridsContainer = document.getElementById("matrixGridsContainer");
			
			// Populate the dropdown and create each matrix grid container.
			matricesInfo.forEach((info, index) => {
				// Add option to select element.
				const option = document.createElement("option");
				option.value = info.name;
				option.textContent = info.label;
				selectEl.appendChild(option);
				
				// Create container div for each grid.
				const gridDiv = document.createElement("div");
				gridDiv.className = "hot-container";
				gridDiv.id = "grid-" + info.name;
				// Hide all grids except the first one.
				gridDiv.style.display = index === 0 ? "block" : "none";
				gridsContainer.appendChild(gridDiv);
				
				// Prepare default data.
				const rows = info.rows(n, p, r);
				const cols = info.cols(n, p, r);
				const data = [];
				for (let i = 0; i < rows; i++) {
					const row = [];
					for (let j = 0; j < cols; j++) {
						if (info.name === "gamma") {
							row.push(i === j ? 1 : 0);
						} else {
							row.push(0);
						}
					}
					data.push(row);
				}
				
				// Create the Handsontable instance.
				matrixGrids[info.name] = new Handsontable(gridDiv, {
					data: data,
					rowHeaders: true,
					colHeaders: true,
					width: cols * 100,
					// Let Handsontable calculate height automatically.
					licenseKey: "non-commercial-and-evaluation"
				});
			});
			
			// Change view when a different matrix is selected.
			selectEl.addEventListener("change", function () {
				const selectedMatrix = this.value;
				matricesInfo.forEach(info => {
					const gridDiv = document.getElementById("grid-" + info.name);
					gridDiv.style.display = info.name === selectedMatrix ? "block" : "none";
				});
			});
			
			// Show the matrix inputs, reset button, and the run button.
			container.classList.remove("hidden");
			document.getElementById("resetMatricesBtn").classList.remove("hidden");
			document.getElementById("runPanel").classList.remove("hidden");
		});
		
		// Reset matrices to default values.
		document.getElementById("resetMatricesBtn").addEventListener("click", function () {
			const n = parseInt(document.getElementById("nInput").value);
			const p = parseInt(document.getElementById("pInput").value);
			const r = parseInt(document.getElementById("rInput").value);
			matricesInfo.forEach(info => {
				const rows = info.rows(n, p, r);
				const cols = info.cols(n, p, r);
				const newData = [];
				for (let i = 0; i < rows; i++) {
					const row = [];
					for (let j = 0; j < cols; j++) {
						if (info.name === "gamma") {
							row.push(i === j ? 1 : 0);
						} else {
							row.push(0);
						}
					}
					newData.push(row);
				}
				matrixGrids[info.name].loadData(newData);
			});
		});
		
		// When "Run Kalman Filter" is clicked, gather all matrix values and call the backend.
		document.getElementById("runKalmanBtn").addEventListener("click", function () {
			const n = parseInt(document.getElementById("nInput").value);
			const p = parseInt(document.getElementById("pInput").value);
			const r = parseInt(document.getElementById("rInput").value);
			const matrices = {};
			
			matricesInfo.forEach(info => {
				matrices[info.name] = matrixGrids[info.name].getData();
			});
			
			const data = {
				n: n,
				p: p,
				r: r,
				matrices: matrices
			};
			
			// Call the backend.
			fetch("http://localhost:5000/run_kalman", {
				method: "POST",
				headers: { "Content-Type": "application/json" },
				body: JSON.stringify(data)
			})
			.then(response => response.json())
			.then(result => {
				console.log("Run result:", result);
				document.getElementById("matrixInputPanel").classList.add("hidden");
				document.getElementById("diagramPanel").classList.remove("hidden");
				fetchGraphStep(); // Draw the first step.
			})
			.catch(error => {
				console.error("Error calling backend:", error);
			});
		});
		
		/***** INFLUENCE DIAGRAM CODE USING D3 *****/
		const svg = d3.select("#graph");
		const linkGroup = svg.append("g").attr("class", "links");
		const nodeGroup = svg.append("g").attr("class", "nodes");
		const textGroup = svg.append("g").attr("class", "texts");
		
		svg.append("defs")
		.append("marker")
		.attr("id", "arrow")
		.attr("viewBox", "0 -5 10 10")
		.attr("refX", 28)
		.attr("refY", 0)
		.attr("markerWidth", 6)
		.attr("markerHeight", 6)
		.attr("orient", "auto")
		.append("path")
		.attr("d", "M0,-5L10,0L0,5")
		.attr("fill", "#999");
		
		function openModal(htmlContent) {
			d3.select("#modalContent").html(htmlContent);
			d3.select("#modalOverlay").style("display", "block");
		}
		function closeModal() {
			d3.select("#modalOverlay").style("display", "none");
		}
		document.getElementById("closeBtn").onclick = closeModal;
		
		function fetchGraphStep() {
			fetch("http://localhost:5000/graph_step")
			.then(res => {
				if (!res.ok) throw new Error("Network response was not OK");
				return res.json();
			})
			.then(data => updateGraph(data))
			.catch(err => console.error("Error fetching graph step:", err));
		}
		
		function updateGraph(data) {
			const nodes = data.nodes || [];
			const edges = data.edges || [];
			
			const linkSel = linkGroup.selectAll(".link")
			.data(edges, d => d.source + "-" + d.target);
			linkSel.exit().remove();
			const linkEnter = linkSel.enter().append("line")
			.attr("class", "link");
			const allLinks = linkEnter.merge(linkSel);
			
			const nodeSel = nodeGroup.selectAll(".node")
			.data(nodes, d => d.id);
			nodeSel.exit().remove();
			const nodeEnter = nodeSel.enter().append("g")
			.attr("class", "node");
			
			nodeEnter.append("circle")
			.attr("r", 20)
			.attr("fill", d => d.color || "#ccc");
			
			nodeEnter.on("click", (event, d) => {
				if (d.color && d.color.toLowerCase() === "#7f7f7f") return;
				const dist = d.distribution || {};
				const meanStr = Array.isArray(dist.mean)
				? JSON.stringify(dist.mean)
				: dist.mean;
				const covStr = Array.isArray(dist.cov)
				? JSON.stringify(dist.cov)
				: dist.cov;
				const html = `
			<h3>${d.id}</h3>
			<p><strong>Mean:</strong> ${meanStr || "?"}</p>
			<p><strong>Covariance:</strong> ${covStr || "?"}</p>
		  `;
				openModal(html);
			});
			
			const allNodes = nodeEnter.merge(nodeSel);
			const textSel = textGroup.selectAll(".nodetext")
			.data(nodes, d => d.id);
			textSel.exit().remove();
			const textEnter = textSel.enter().append("text")
			.attr("class", "nodetext")
			.text(d => d.id);
			const allTexts = textEnter.merge(textSel);
			
			allNodes.attr("transform", d => `translate(${d.x},${d.y})`);
			allTexts.attr("x", d => d.x)
			.attr("y", d => d.y);
			
			allLinks
			.attr("x1", d => {
				const src = nodes.find(n => n.id === d.source);
				return src ? src.x : 0;
			})
			.attr("y1", d => {
				const src = nodes.find(n => n.id === d.source);
				return src ? src.y : 0;
			})
			.attr("x2", d => {
				const tgt = nodes.find(n => n.id === d.target);
				return tgt ? tgt.x : 0;
			})
			.attr("y2", d => {
				const tgt = nodes.find(n => n.id === d.target);
				return tgt ? tgt.y : 0;
			});
		}
		
		document.getElementById("nextStepBtn").onclick = () => {
			fetch("http://localhost:5000/next_step", { method: "POST" })
			.then(res => res.json())
			.then(data => {
				console.log("Now at step:", data.current_step);
				fetchGraphStep();
			})
			.catch(err => console.error("Error going to next step:", err));
		};
		
		document.getElementById("prevStepBtn").onclick = () => {
			fetch("http://localhost:5000/prev_step", { method: "POST" })
			.then(res => res.json())
			.then(data => {
				console.log("Now at step:", data.current_step);
				fetchGraphStep();
			})
			.catch(err => console.error("Error going to previous step:", err));
		};
		
		document.getElementById("backToInputBtn").addEventListener("click", function () {
			document.getElementById("diagramPanel").classList.add("hidden");
			document.getElementById("matrixInputPanel").classList.remove("hidden");
		});
	</script>
</body>
</html>
